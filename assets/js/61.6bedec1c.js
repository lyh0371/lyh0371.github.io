(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{150:function(a,t,s){"use strict";s.r(t);var e=s(0),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"网络层面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络层面"}},[a._v("#")]),a._v(" 网络层面")]),a._v(" "),s("h2",{attrs:{id:"构建请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建请求"}},[a._v("#")]),a._v(" 构建请求")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 请求方法是GET，路径为根路径，HTTP协议版本为1.1")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GET")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("HTTP")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("h2",{attrs:{id:"查找强缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查找强缓存"}},[a._v("#")]),a._v(" 查找强缓存")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[a._v("先检查强缓存，如果命中直接使用，否则进入下一步\n")])])]),s("h2",{attrs:{id:"dns-解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns-解析"}},[a._v("#")]),a._v(" DNS 解析")]),a._v(" "),s("p",[a._v("由于我们输入的是域名，而数据包是通过 IP 地址传给对方的。因此我们需要得到域名对应的 IP 地址。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做 DNS（域名系统）。得到具体 IP 的过程就是 DNS 解析。\n当然，值得注意的是，浏览器提供了 DNS 数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS 解析。\n另外，如果不指定端口的话，默认采用对应的 IP 的 80 端口。")]),a._v(" "),s("p",[a._v("DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：")]),a._v(" "),s("ol",[s("li",[a._v("根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务\n器的 IP 地址；")]),a._v(" "),s("li",[a._v("顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务\n器可以返回 apple.com 域名服务器的 IP 地址；")]),a._v(" "),s("li",[a._v("权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名\n服务器可以返回 www.apple.com 的 IP 地址。")])]),a._v(" "),s("p",[a._v("例如，你要访问“www.apple.com”，就要进行下面的三次查询：")]),a._v(" "),s("ol",[s("li",[a._v("访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；")]),a._v(" "),s("li",[a._v("访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；")]),a._v(" "),s("li",[a._v("最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址")])]),a._v(" "),s("h2",{attrs:{id:"建立-tcp-连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#建立-tcp-连接"}},[a._v("#")]),a._v(" 建立 TCP 连接")]),a._v(" "),s("p",[s("strong",[a._v("建立 TCP 连接经历了下面三个阶段")])]),a._v(" "),s("ul",[s("li",[a._v("通过三次握手(即总共发送 3 个数据包确认已经建立连接)建立客户端和服务器之间的连接。")]),a._v(" "),s("li",[a._v("进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。")]),a._v(" "),s("li",[a._v("断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。")])]),a._v(" "),s("p",[a._v("TCP 就是通过三次握手确认连接，数据包校验保证数据到达接收方，然后通过四次挥手断开连接保证数据传输的可靠性")]),a._v(" "),s("h2",{attrs:{id:"发送-http-请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发送-http-请求"}},[a._v("#")]),a._v(" 发送 HTTP 请求")]),a._v(" "),s("p",[a._v("现在 TCP 连接建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:请求行、请求头和请求体")]),a._v(" "),s("h2",{attrs:{id:"网络响应"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络响应"}},[a._v("#")]),a._v(" 网络响应")]),a._v(" "),s("p",[a._v("HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。")]),a._v(" "),s("p",[a._v("跟请求部分类似，网络响应具有三个部分:响应行、响应头和响应体。")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("HTTP")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("200")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("OK")]),a._v("\n")])])]),s("p",[a._v("由 HTTP 协议版本、状态码和状态描述组成。")]),a._v(" "),s("p",[a._v("响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的 Cookie 信息")]),a._v(" "),s("p",[s("strong",[a._v("如果请求头或响应头中包含 Connection: Keep-Alive，表示建立了持久连接，这样 TCP 连接会一直保持，之后请求统一站点的资源会复用这个连接")])]),a._v(" "),s("h1",{attrs:{id:"页面渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染"}},[a._v("#")]),a._v(" 页面渲染")]),a._v(" "),s("p",[a._v("完成了网络层面,接下来就是浏览器"),s("code",[a._v("解析")]),a._v("及"),s("code",[a._v("渲染")]),a._v("的步骤了")]),a._v(" "),s("h2",{attrs:{id:"解析过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解析过程"}},[a._v("#")]),a._v(" 解析过程")]),a._v(" "),s("h3",{attrs:{id:"构建-dom-树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建-dom-树"}},[a._v("#")]),a._v(" 构建 DOM 树")]),a._v(" "),s("p",[a._v("由于浏览器无法直接理解 HTML 字符串，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是 DOM 树。DOM 树本质上是一个以 document 为根节点的多叉树")]),a._v(" "),s("h3",{attrs:{id:"样式计算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#样式计算"}},[a._v("#")]),a._v(" 样式计算")]),a._v(" "),s("p",[a._v("首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即 styleSheets。\n这个格式化的过程过于复杂，而且对于不同的浏览器会有不同的优化策略，这里就不展开了。\n在浏览器控制台能够通过"),s("code",[a._v("document.styleSheets")]),a._v("来查看这个最终的结构。当然，这个结构包含了以上三种 CSS 来源，为后面的样式操作提供了基础。")]),a._v(" "),s("h3",{attrs:{id:"生成布局树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成布局树"}},[a._v("#")]),a._v(" 生成布局树")]),a._v(" "),s("p",[a._v("现在已经生成了 DOM 树和 DOM 样式，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一棵布局树(Layout Tree)。\n布局树生成的大致工作如下:")]),a._v(" "),s("ul",[s("li",[a._v("遍历生成的 DOM 树节点，并把他们添加到布局树中。")]),a._v(" "),s("li",[a._v("计算布局树节点的坐标位置。")])]),a._v(" "),s("p",[a._v("值得注意的是，这棵布局树值包含可见元素，对于 head 标签和设置了 display: none 的元素，将不会被放入其中")]),a._v(" "),s("h2",{attrs:{id:"渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染"}},[a._v("#")]),a._v(" 渲染")]),a._v(" "),s("p",[a._v("浏览器渲染流程是个老生常谈的话题了，对于 “浏览器如何呈现一个页面的内容” 的这类问题，不少人都可以讲出一个相对完整的过程，从网络请求到浏览器解析，可以具体到很多的细节。除去网络资源获取的步骤，我们理解的 Web 页面的展示，一般可以分为 构建 DOM 树、构建渲染树、布局、绘制、渲染层合成 几个步骤。")]),a._v(" "),s("h3",{attrs:{id:"构建-dom-树-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建-dom-树-2"}},[a._v("#")]),a._v(" 构建 DOM 树")]),a._v(" "),s("p",[a._v("浏览器将 HTML 解析成树形结构的 DOM 树，一般来说，这个过程发生在页面初次加载，或页面 JavaScript 修改了节点结构的时候")]),a._v(" "),s("h3",{attrs:{id:"构建渲染树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建渲染树"}},[a._v("#")]),a._v(" 构建渲染树")]),a._v(" "),s("p",[a._v("浏览器将 CSS 解析成树形结构的 CSSOM 树，再和 DOM 树合并成渲染树")]),a._v(" "),s("h3",{attrs:{id:"布局（layout）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#布局（layout）"}},[a._v("#")]),a._v(" 布局（Layout）")]),a._v(" "),s("p",[a._v("浏览器根据渲染树所体现的节点、各个节点的 CSS 定义以及它们的从属关系，计算出每个节点在屏幕中的位置。Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为"),s("code",[a._v("回流（Reflow）")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"绘制（paint）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#绘制（paint）"}},[a._v("#")]),a._v(" 绘制（Paint）")]),a._v(" "),s("p",[a._v("遍历渲染树，调用渲染器的 paint() 方法在屏幕上绘制出节点内容，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为"),s("code",[a._v("重绘（Repaint）")]),a._v("。实际上，绘制过程是在多个层上完成的，这些层我们称为 "),s("strong",[a._v("渲染层（RenderLayer）")])]),a._v(" "),s("h3",{attrs:{id:"渲染层合成（composite）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染层合成（composite）"}},[a._v("#")]),a._v(" 渲染层合成（Composite）")]),a._v(" "),s("p",[a._v("多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上\n"),s("strong",[a._v("什么是渲染层合成")]),a._v(" "),s("br"),a._v("\n在 DOM 树中每个节点都会对应一个"),s("code",[a._v("渲染对象（RenderObject）")]),a._v("，当它们的渲染对象处于相同的坐标空间（z 轴空间）时，就会形成一个 "),s("code",[a._v("RenderLayers")]),a._v("，也就是"),s("code",[a._v("渲染层")]),a._v("。渲染层将保证页面元素以正确的顺序堆叠，这时候就会出现"),s("code",[a._v("层合成（composite）")]),a._v("，从而正确处理透明元素和重叠元素的显示。 "),s("br"),a._v("\n这个模型类似于 Photoshop 的图层模型，在 Photoshop 中，每个设计元素都是一个独立的图层，多个图层以恰当的顺序在 z 轴空间上叠加，最终构成一个完整的设计图。\n对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。")]),a._v(" "),s("h3",{attrs:{id:"显示器显示内容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#显示器显示内容"}},[a._v("#")]),a._v(" 显示器显示内容")]),a._v(" "),s("p",[a._v('栅格化操作完成后，合成线程会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。\n浏览器进程中的 viz 组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。\n无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。\n看到这里你也就是明白，'),s("strong",[a._v("当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。")]),a._v(" "),s("br")]),a._v(" "),s("ul",[s("li",[a._v("渲染对象（RenderObject）")]),a._v(" "),s("li",[a._v("渲染层（RenderLayer）")]),a._v(" "),s("li",[a._v("图形层（GraphicsLayer）")]),a._v(" "),s("li",[a._v("合成层（CompositingLayer）\n"),s("br")])]),a._v(" "),s("p",[a._v("从浏览器的渲染过程中我们知道，页面 HTML 会被解析成 DOM 树，每个 HTML 元素对应了树结构上的一个 node 节点。而从 DOM 树转化到一个个的渲染层，并最终执行合并、绘制的过程，中间其实还存在一些过渡的数据结构，它们记录了 DOM 树到屏幕图形的转化原理，其本质也就是树结构到层结构的演化\n关于浏览器渲染的各种层级, 层爆炸问题,可以看"),s("a",{attrs:{href:"https://juejin.im/post/5da52531518825094e373372#heading-16",target:"_blank",rel:"noopener noreferrer"}},[a._v("这里"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);