(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{163:function(e,o,t){"use strict";t.r(o);var a=t(0),i=Object(a.a)({},(function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"cookie-的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的作用"}},[e._v("#")]),e._v(" Cookie 的作用")]),e._v(" "),t("p",[e._v("HTTP 是“无状态”的，这既是优点也是缺点。优点是服务器没有状\n态差异，可以很容易地组成集群，而缺点就是无法支持需要记录状态的事务操作\n"),t("strong",[e._v("Cookie 就是为了弥补 HTTP 无状态的缺点而生")])]),e._v(" "),t("h2",{attrs:{id:"cookie-的工作过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的工作过程"}},[e._v("#")]),e._v(" Cookie 的工作过程")]),e._v(" "),t("p",[e._v("这要用到两个字段：响应头字段 "),t("code",[e._v("Set-Cookie")]),e._v(" 和请求头字段 "),t("code",[e._v("Cookie")]),e._v("\n比如：当用户通过浏览器第一次访问服务器的时候，服务器肯定是不知道他的身份的。所以，就要创建一个独特的\n身份标识数据，格式是“key=value”，然后放进 Set-Cookie 字段里，随着响应报文一同发给浏览器。\n浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保存起来，下次再请\n求的时候就自动把这个值放进 Cookie 字段里发给服务器")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("不过因为服务器的“记忆能力”实在是太差，一张小纸条经常不够用。所以，服务器有时会在响应头里添加\n多个 Set-Cookie，存储多个“key=value”。但浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里\n用“;”隔开就行")])]),e._v(" "),t("p",[t("strong",[e._v("注意： Cookie 是由浏览器负责存储的，而不是操作系统")])]),e._v(" "),t("h2",{attrs:{id:"cookie-的生存周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的生存周期"}},[e._v("#")]),e._v(" Cookie 的生存周期")]),e._v(" "),t("p",[e._v("Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。\n“Expires”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）。“MaxAge”用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时\n间。\nExpires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器会优先采用 Max-Age\n计算失效期。")])])}),[],!1,null,null,null);o.default=i.exports}}]);