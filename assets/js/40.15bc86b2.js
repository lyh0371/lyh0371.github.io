(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{198:function(e,v,t){"use strict";t.r(v);var _=t(0),r=Object(_.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue-运行机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-运行机制"}},[e._v("#")]),e._v(" vue 运行机制")]),e._v(" "),t("h2",{attrs:{id:"初始化-new-vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化-new-vue"}},[e._v("#")]),e._v(" 初始化 new vue()")]),e._v(" "),t("p",[e._v("在 "),t("strong",[e._v("new Vue()")]),e._v(" 之后。 "),t("code",[e._v("Vue")]),e._v(" 会调用 "),t("code",[e._v("_init")]),e._v(" 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、"),t("code",[e._v("props、 methods、 data、 computed 与 watch")]),e._v("等。其中最重要的是通过 "),t("code",[e._v("Object.defineProperty")]),e._v(" 设置 "),t("code",[e._v("setter")]),e._v(" 与 "),t("code",[e._v("getter")]),e._v(" 函数，用来实现「响应式」以及「依赖收集」")]),e._v(" "),t("h2",{attrs:{id:"compile-编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compile-编译"}},[e._v("#")]),e._v(" compile 编译")]),e._v(" "),t("p",[e._v("编译可分为 三个阶段")]),e._v(" "),t("ul",[t("li",[e._v("parse (会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST)")]),e._v(" "),t("li",[e._v("optimize (的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能)")]),e._v(" "),t("li",[e._v("generate (是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串)\n"),t("br"),e._v("\n在经历了三个阶段后,组件中就会存在渲染VNode所需的render function")])]),e._v(" "),t("h2",{attrs:{id:"响应式-数据双向绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应式-数据双向绑定"}},[e._v("#")]),e._v(" 响应式 数据双向绑定")]),e._v(" "),t("p",[e._v("在vue初始化时 数据通过了"),t("code",[e._v("Object.defineProperty")]),e._v("进行双向绑定,当数据被读取时会执行"),t("code",[e._v("get")]),e._v("方法 当数据被修改时会执行"),t("code",[e._v("set")]),e._v("方法从而进行数据的渲染"),t("br"),e._v("\n在 "),t("code",[e._v("get")]),e._v(" 的 在渲染的时候会进行 "),t("strong",[e._v("依赖收集")]),e._v(",的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 "),t("code",[e._v("Dep")]),e._v(" 的 "),t("code",[e._v("subs")]),e._v(" 中 在"),t("code",[e._v("set")]),e._v("修改的时候会通知依赖收集,告诉他们被依赖的数据改变了,需要在重新更新视图,当然这中间还有一个 "),t("strong",[e._v("patch")]),e._v(" 的过程以及 "),t("strong",[e._v("使用队列来异步更新")]),e._v(" 的策略")]),e._v(" "),t("h2",{attrs:{id:"virtual-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[e._v("#")]),e._v(" Virtual DOM")]),e._v(" "),t("p",[t("code",[e._v("render function")]),e._v(" 会被转化成 "),t("code",[e._v("VNode")]),e._v(" 节点。"),t("code",[e._v("Virtual DOM")]),e._v(" 其实就是一棵以 "),t("code",[e._v("JavaScript")]),e._v(" 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。")]),e._v(" "),t("h2",{attrs:{id:"更新视图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更新视图"}},[e._v("#")]),e._v(" 更新视图")]),e._v(" "),t("p",[e._v("当数据变化后，执行"),t("code",[e._v("render function")]),e._v("就可以得到一个新的 "),t("code",[e._v("VNode")]),e._v(" 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 "),t("code",[e._v("VNode")]),e._v(" 节点，然后用 "),t("code",[e._v("innerHTML")]),e._v(" 直接全部渲染到真实 "),t("code",[e._v("DOM")]),e._v(" 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。")]),e._v(" "),t("p",[e._v("那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[t("strong",[e._v("vue运行机制")]),e._v(" "),t("br")]),e._v(" "),t("p",[t("code",[e._v("setter")]),e._v(" -> "),t("code",[e._v("watcher")]),e._v(" -> "),t("code",[e._v("updata")]),e._v(" -> "),t("code",[e._v("render function")]),e._v(" -> "),t("code",[e._v("VNode")]),e._v(" -> "),t("code",[e._v("patch")]),e._v(" -> "),t("code",[e._v("diff")]),e._v(" -> "),t("code",[e._v("change")])])])}),[],!1,null,null,null);v.default=r.exports}}]);