(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{146:function(t,a,s){"use strict";s.r(a);var v=s(0),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"浏览器对打开新页面的处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器对打开新页面的处理"}},[t._v("#")]),t._v(" 浏览器对打开新页面的处理")]),t._v(" "),s("p",[t._v("默认情况下，chrome会为每个页面分配一个渲染进程，也就是说每打开一个新页面就会配套创建一个新的渲染进程。但是在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。")]),t._v(" "),s("h1",{attrs:{id:"那什么情况下多个页面会同时运行在一个渲染进程中呢"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#那什么情况下多个页面会同时运行在一个渲染进程中呢"}},[t._v("#")]),t._v(" 那什么情况下多个页面会同时运行在一个渲染进程中呢")]),t._v(" "),s("p",[t._v("要解决这个问题，我们就需要先了解下什么是同一站点（same-site）。具体地讲，我们将“"),s("strong",[t._v("同一站点")]),t._v("”定义为 "),s("strong",[t._v("根域名")]),t._v("（例如，geekbang.org）加上 "),s("strong",[t._v("协议")]),t._v("（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("https"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("geekbang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("org\nhttps"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("www"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("geekbang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("org\nhttps"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("www"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("geekbang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("org"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8080")]),t._v("\n\n")])])]),s("p",[t._v("它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org "),s("br"),t._v("\nChrome 的默认策略是，每个标签对应一个渲染进程。但 "),s("strong",[t._v("如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程")]),t._v("。官方把这个默认策略叫 process-per-site-instance")]),t._v(" "),s("h1",{attrs:{id:"提交文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#提交文档"}},[t._v("#")]),t._v(" 提交文档")]),t._v(" "),s("p",[t._v("首先要明确一点，这里的“文档”是指 URL 请求的响应体数据。")]),t._v(" "),s("ul",[s("li",[t._v("“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。")]),t._v(" "),s("li",[t._v("等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。")]),t._v(" "),s("li",[t._v("浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面\n这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。")])]),t._v(" "),s("p",[t._v("到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。")]),t._v(" "),s("h1",{attrs:{id:"渲染阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染阶段"}},[t._v("#")]),t._v(" 渲染阶段")]),t._v(" "),s("h2",{attrs:{id:"构建-dom-树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建-dom-树"}},[t._v("#")]),t._v(" 构建 DOM 树")]),t._v(" "),s("p",[t._v("为什么要构建 DOM 树呢？"),s("strong",[t._v("这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树")]),t._v("\n为了更加直观地理解 DOM 树，你可以打开 Chrome 的“开发者工具”，选择“Console”标签来打开控制台，然后在控制台里面输入“"),s("code",[t._v("document")]),t._v("”后回车，这样你就能看到一个完整的 DOM 树结构 "),s("br"),t._v("\n现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了")]),t._v(" "),s("h2",{attrs:{id:"样式计算（recalculate-style）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#样式计算（recalculate-style）"}},[t._v("#")]),t._v(" 样式计算（Recalculate Style）")]),t._v(" "),s("p",[t._v("样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。")]),t._v(" "),s("h3",{attrs:{id:"_1-把-css-转换为浏览器能够理解的结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-把-css-转换为浏览器能够理解的结构"}},[t._v("#")]),t._v(" 1. 把 CSS 转换为浏览器能够理解的结构")]),t._v(" "),s("p",[t._v("和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以 "),s("strong",[t._v("当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets")]),t._v("。\n为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets")]),t._v(" "),s("h3",{attrs:{id:"_2-转换样式表中的属性值，使其标准化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-转换样式表中的属性值，使其标准化"}},[t._v("#")]),t._v(" 2. 转换样式表中的属性值，使其标准化")]),t._v(" "),s("p",[t._v("现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。")]),t._v(" "),s("p",[t._v("要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本")]),t._v(" "),s("div",{staticClass:"language-css extra-class"},[s("pre",{pre:!0,attrs:{class:"language-css"}},[s("code",[s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("body")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-size")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 2em "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("p")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("blue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("span")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" none"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("font-weight")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" bold"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div  p")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("green"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("red"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以 "),s("strong",[t._v("需要将所有值转换为渲染引擎容易理解的、标准化的计算值")]),t._v("，这个过程就是属性值标准化")]),t._v(" "),s("h3",{attrs:{id:"_3-计算出-dom-树中每个节点的具体样式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-计算出-dom-树中每个节点的具体样式"}},[t._v("#")]),t._v(" 3. 计算出 DOM 树中每个节点的具体样式")]),t._v(" "),s("ul",[s("li",[t._v("首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式")]),t._v(" "),s("li",[t._v("样式计算过程中的第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。关于层叠的具体规则这里就不做过多介绍了，网上资料也非常多，你可以自行搜索学习。")])]),t._v(" "),s("p",[t._v("总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内")]),t._v(" "),s("h2",{attrs:{id:"布局阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#布局阶段"}},[t._v("#")]),t._v(" 布局阶段")]),t._v(" "),s("p",[t._v("现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局 "),s("br"),t._v("\nChrome 在布局阶段需要完成两个任务："),s("strong",[t._v("创建布局树和布局计算")])]),t._v(" "),s("h3",{attrs:{id:"_1-创建布局树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建布局树"}},[t._v("#")]),t._v(" 1. 创建布局树")]),t._v(" "),s("p",[t._v("你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树,为了构建布局树，浏览器大体上完成了下面这些工作:")]),t._v(" "),s("ul",[s("li",[t._v("遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；")]),t._v(" "),s("li",[t._v("而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。")])]),t._v(" "),s("h3",{attrs:{id:"_2-布局计算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-布局计算"}},[t._v("#")]),t._v(" 2. 布局计算")]),t._v(" "),s("h2",{attrs:{id:"分层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[t._v("#")]),t._v(" 分层")]),t._v(" "),s("p",[t._v("面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，"),s("strong",[t._v("渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面")]),t._v(" 原理如同ps\n浏览器有一个父图层,那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面任意一点的元素就可以被提升为单独的一个图层。")]),t._v(" "),s("ul",[s("li",[t._v("3D 或透视变换(perspective transform) CSS 属性")]),t._v(" "),s("li",[t._v("使用加速视频解码的 "),s("code",[t._v("<video>")]),t._v(" 元素 拥有 3D")]),t._v(" "),s("li",[t._v("(WebGL) 上下文或加速的 2D 上下文的 "),s("code",[t._v("<canvas>")]),t._v(" 元素")]),t._v(" "),s("li",[t._v("混合插件(如 Flash)")]),t._v(" "),s("li",[t._v("对自己的 opacity 做 CSS动画或使用一个动画变换的元素")]),t._v(" "),s("li",[t._v("拥有加速 CSS 过滤器的元素")]),t._v(" "),s("li",[t._v("元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)")]),t._v(" "),s("li",[t._v("元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)")])]),t._v(" "),s("h2",{attrs:{id:"图层绘制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[t._v("#")]),t._v(" 图层绘制")]),t._v(" "),s("p",[t._v("在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，那么接下来我们看看渲染引擎是怎么实现图层绘制的？"),s("br")]),t._v(" "),s("p",[t._v("试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？ "),s("br"),t._v("\n通常，你会把你的绘制操作分解为三步：")]),t._v(" "),s("ul",[s("li",[t._v("绘制蓝色背景；")]),t._v(" "),s("li",[t._v("在中间绘制一个红色的圆；")]),t._v(" "),s("li",[t._v("再在圆上绘制绿色三角形。\n渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表")])]),t._v(" "),s("h2",{attrs:{id:"栅格化（raster）操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#栅格化（raster）操作"}},[t._v("#")]),t._v(" 栅格化（raster）操作")]),t._v(" "),s("p",[t._v("绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。")]),t._v(" "),s("p",[s("strong",[t._v("视口")]),t._v(" "),s("br"),t._v("\n通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。")]),t._v(" "),s("p",[t._v("在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。")]),t._v(" "),s("p",[t._v("基于这个原因，"),s("strong",[t._v("合成线程会将图层划分为图块（tile）")])]),t._v(" "),s("p",[t._v("然后 "),s("strong",[t._v("合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图")]),t._v("。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的 "),s("br"),t._v("\n通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中 "),s("br"),t._v("\n相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图\n"),s("img",{attrs:{src:"/imgs/%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B.png",alt:"渲染进程"}}),t._v("\n从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中")]),t._v(" "),s("h2",{attrs:{id:"合成和显示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合成和显示"}},[t._v("#")]),t._v(" 合成和显示")]),t._v(" "),s("p",[t._v("一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。")]),t._v(" "),s("p",[t._v("浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。")]),t._v(" "),s("p",[t._v("到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。")]),t._v(" "),s("h2",{attrs:{id:"渲染流水线大总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染流水线大总结"}},[t._v("#")]),t._v(" 渲染流水线大总结")]),t._v(" "),s("p",[s("img",{attrs:{src:"/imgs/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.png",alt:"渲染流程总结"}})]),t._v(" "),s("p",[t._v("结合上图，一个完整的渲染流程大致可总结为如下：")]),t._v(" "),s("ul",[s("li",[t._v("渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。")]),t._v(" "),s("li",[t._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。")]),t._v(" "),s("li",[t._v("创建布局树，并计算元素的布局信息。")]),t._v(" "),s("li",[t._v("对布局树进行分层，并生成分层树。")]),t._v(" "),s("li",[t._v("为每个图层生成绘制列表，并将其提交到合成线程。")]),t._v(" "),s("li",[t._v("合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。")]),t._v(" "),s("li",[t._v("合成线程发送绘制图块命令DrawQuad给浏览器进程。")]),t._v(" "),s("li",[t._v("浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上")])]),t._v(" "),s("h2",{attrs:{id:"关于重排、重绘和合成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于重排、重绘和合成"}},[t._v("#")]),t._v(" 关于重排、重绘和合成")]),t._v(" "),s("p",[t._v("这三种方式的渲染路径是不同的，"),s("strong",[t._v("通常渲染路径越长，生成图像花费的时间就越多")]),t._v(" 。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。")]),t._v(" "),s("p",[t._v("相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。")]),t._v(" "),s("p",[t._v("所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。")]),t._v(" "),s("p",[t._v("本文我们的焦点在合成上，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结："),s("strong",[t._v("分层、分块和合成")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"关于分成与合成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于分成与合成"}},[t._v("#")]),t._v(" 关于分成与合成")]),t._v(" "),s("p",[t._v("通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。")]),t._v(" "),s("p",[t._v("为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？")]),t._v(" "),s("p",[t._v("你可以把一张网页想象成是由很 "),s("strong",[t._v("多个图片叠加在一起")]),t._v(" 的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。")]),t._v(" "),s("p",[t._v("在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。")]),t._v(" "),s("p",[t._v("考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。")]),t._v(" "),s("p",[t._v("理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。")]),t._v(" "),s("p",[t._v("在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。\n有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。")]),t._v(" "),s("p",[t._v("需要重点关注的是，"),s("strong",[t._v("合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"关于分块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于分块"}},[t._v("#")]),t._v(" 关于分块")]),t._v(" "),s("p",[t._v("如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。")]),t._v(" "),s("p",[t._v("通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。")]),t._v(" "),s("p",[t._v("因此，"),s("strong",[t._v("合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度")]),t._v("。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。")]),t._v(" "),s("p",[t._v("为了解决这个问题，Chrome 又采取了一个策略："),s("strong",[t._v("在首次合成图块的时候使用一个低分辨率的图片")]),t._v("。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好")])])}),[],!1,null,null,null);a.default=_.exports}}]);